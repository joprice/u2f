<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>U2f (u2f.U2f)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">u2f</a> &#x00BB; U2f</nav><h1>Module <code>U2f</code></h1><p>U2F - Universal Second Factor</p><p>U2F is a standard for two-factor authentication with special USB or NFC devices. A challenge-response authentication with the device using public key cryptography is done.</p><p>This library is stateless, a client of this API has to preserve challenges (for register/authentication session), and for each registered device a quadruple of key handle, public key, certificate, and counter.</p><p>A common use of this module is that on startup a <a href="index.html#type-t"><code>t</code></a> is created. For a registration, first <a href="index.html#val-register_request"><code>register_request</code></a> is called (the challenge is preserved, the data is sent to the client), and <a href="index.html#val-register_response"><code>register_response</code></a> is called with the client response (and the same challenge). If the verification succeeds, the client information (public key, key handle) is returned. To authenticate the function <a href="index.html#val-authentication_request"><code>authentication_request</code></a> is called with the non-empty list of registered key handles. The resulting challenge is preserved, the data is sent to the client. Upon a response from the client, <a href="index.html#val-authentication_response"><code>authentication_response</code></a> should be called with the association list of key handle and public key, the challenge, and the client response.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of a u2f state, containing the version string and application ID.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create application_id</code> creates a u2f state with the provided application ID. The application ID is not validated.</p></dd></dl><dl><dt class="spec type" id="type-protocol_error"><a href="#type-protocol_error" class="anchor"></a><code><span class="keyword">type</span> protocol_error</code> = <code>[ </code><table class="variant"><tr id="type-protocol_error.Other_error" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Other_error" class="anchor"></a><code>| </code><code>`Other_error</code></td></tr><tr id="type-protocol_error.Bad_request" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Bad_request" class="anchor"></a><code>| </code><code>`Bad_request</code></td></tr><tr id="type-protocol_error.Configuration_unsupported" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Configuration_unsupported" class="anchor"></a><code>| </code><code>`Configuration_unsupported</code></td></tr><tr id="type-protocol_error.Device_ineligible" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Device_ineligible" class="anchor"></a><code>| </code><code>`Device_ineligible</code></td></tr><tr id="type-protocol_error.Timeout" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Timeout" class="anchor"></a><code>| </code><code>`Timeout</code></td></tr><tr id="type-protocol_error.Unrecognized" class="anchored"><td class="def constructor"><a href="#type-protocol_error.Unrecognized" class="anchor"></a><code>| </code><code>`Unrecognized <span class="keyword">of</span> int</code></td></tr></table><code> ]</code></dt><dd><p>The type of protocol errors, as specified by the standard.</p></dd></dl><dl><dt class="spec value" id="val-pp_protocol_error"><a href="#val-pp_protocol_error" class="anchor"></a><code><span class="keyword">val</span> pp_protocol_error : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-protocol_error">protocol_error</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_protocol_error ppf error</code> pretty-prints the protocol <code>error</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Protocol" class="anchored"><td class="def constructor"><a href="#type-error.Protocol" class="anchor"></a><code>| </code><code>`Protocol <span class="keyword">of</span> <a href="index.html#type-protocol_error">protocol_error</a></code></td></tr><tr id="type-error.Json_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Json_decoding" class="anchor"></a><code>| </code><code>`Json_decoding <span class="keyword">of</span> string * string * string</code></td></tr><tr id="type-error.Base64_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Base64_decoding" class="anchor"></a><code>| </code><code>`Base64_decoding <span class="keyword">of</span> string * string * string</code></td></tr><tr id="type-error.Binary_decoding" class="anchored"><td class="def constructor"><a href="#type-error.Binary_decoding" class="anchor"></a><code>| </code><code>`Binary_decoding <span class="keyword">of</span> string * string * string</code></td></tr><tr id="type-error.Version_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Version_mismatch" class="anchor"></a><code>| </code><code>`Version_mismatch <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.Typ_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Typ_mismatch" class="anchor"></a><code>| </code><code>`Typ_mismatch <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.Challenge_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Challenge_mismatch" class="anchor"></a><code>| </code><code>`Challenge_mismatch <span class="keyword">of</span> string * string</code></td></tr><tr id="type-error.Unknown_key_handle" class="anchored"><td class="def constructor"><a href="#type-error.Unknown_key_handle" class="anchor"></a><code>| </code><code>`Unknown_key_handle <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Signature_verification" class="anchored"><td class="def constructor"><a href="#type-error.Signature_verification" class="anchor"></a><code>| </code><code>`Signature_verification <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Origin_mismatch" class="anchored"><td class="def constructor"><a href="#type-error.Origin_mismatch" class="anchor"></a><code>| </code><code>`Origin_mismatch <span class="keyword">of</span> string * string</code></td></tr></table><code> ]</code></dt><dd><p>The type of errors when verifying client responses.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-error">error</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>pp_error ppf error</code> pretty-prints the <code>error</code> on <code>ppf</code>.</p></dd></dl><dl><dt class="spec type" id="type-challenge"><a href="#type-challenge" class="anchor"></a><code><span class="keyword">type</span> challenge</code><code> = string</code></dt><dd><p>The type alias of a challenge.</p></dd></dl><dl><dt class="spec type" id="type-key_handle"><a href="#type-key_handle" class="anchor"></a><code><span class="keyword">type</span> key_handle</code><code> = string</code></dt><dd><p>The type alias of a key handle.</p></dd></dl><dl><dt class="spec value" id="val-register_request"><a href="#val-register_request" class="anchor"></a><code><span class="keyword">val</span> register_request : <span>?&#8288;key_handles:<span><a href="index.html#type-key_handle">key_handle</a> list</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> * string</code></dt><dd><p><code>register_request ~key_handles t</code> results in a challenge and data to be sent to the client. The <code>key_handles</code> should be the already registered key handles for this account. The <code>challenge</code> is randomly generated, and unique for this session. It must be passed to <a href="index.html#val-register_response"><code>register_response</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-register_response"><a href="#val-register_response" class="anchor"></a><code><span class="keyword">val</span> register_response : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(Mirage_crypto_ec.P256.Dsa.pub * <a href="index.html#type-key_handle">key_handle</a> * X509.Certificate.t, <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>register_response t challenge client_data</code> verifies the <code>client_data</code> with the provided <code>challenge</code>, and data in <code>t</code> (application ID, version). On success, a tuple of public key, key handle, and certificate is returned. On error, the specific error is returned.</p></dd></dl><dl><dt class="spec value" id="val-authentication_request"><a href="#val-authentication_request" class="anchor"></a><code><span class="keyword">val</span> authentication_request : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-key_handle">key_handle</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> * string</code></dt><dd><p><code>authentication_request t key_handles</code> randomly generates a challenge, and returns both the challenge (unique for this session, should be preserved and must be passed to <a href="index.html#val-authentication_response"><code>authentication_response</code></a>), and the data to be sent to the client.</p></dd></dl><dl><dt class="spec value" id="val-authentication_response"><a href="#val-authentication_response" class="anchor"></a><code><span class="keyword">val</span> authentication_response : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="index.html#type-key_handle">key_handle</a> * Mirage_crypto_ec.P256.Dsa.pub)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-challenge">challenge</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span>(<a href="index.html#type-key_handle">key_handle</a> * Mirage_crypto_ec.P256.Dsa.pub)</span> * bool * int32, <a href="index.html#type-error">error</a>)</span> Stdlib.result</span></code></dt><dd><p><code>authentication_response t key_handle_pub challenge client_data</code> verifies the <code>client_data</code> using the <code>challenge</code> and looks it up in the <code>key_handle_pub</code> associative list. If successful, the used key handle and public key is returned, also a boolen whether the user was present, and the counter - an unsigned 32 bit integer. The counter should be verified to be strictly monotonically increasing for the key handle and public key.</p></dd></dl></div></body></html>